import{_ as s,o as a,c as n,S as l}from"./chunks/framework.a3dd33a8.js";const t="/doc/assets/20230918_1452198268.09c39a3a.png",o="/doc/assets/20230918_1452199646.39e1f015.png",e="/doc/assets/20230918_1452217163.1317c5df.png",p="/doc/assets/20230918_1452218628.9c44da72.png",c="/doc/assets/20230918_1452223940.041ef4b6.png",i="/doc/assets/20230918_1452223788.0cf80bce.png",r="/doc/assets/20230918_1452232431.a17467bc.png",u=JSON.parse('{"title":"代码生成模块最佳实践","description":"","frontmatter":{},"headers":[],"relativePath":"base/product/DDD可视化开发平台文档/最佳实践/代码生成模块最佳实践.md","filePath":"base/product/DDD可视化开发平台文档/最佳实践/代码生成模块最佳实践.md","lastUpdated":1706585121000}'),y={name:"base/product/DDD可视化开发平台文档/最佳实践/代码生成模块最佳实践.md"},E=l(`<h1 id="代码生成模块最佳实践" tabindex="-1">代码生成模块最佳实践 <a class="header-anchor" href="#代码生成模块最佳实践" aria-label="Permalink to &quot;代码生成模块最佳实践&quot;">​</a></h1><h2 id="一、概述" tabindex="-1">一、概述 <a class="header-anchor" href="#一、概述" aria-label="Permalink to &quot;一、概述&quot;">​</a></h2><p>为了简化开发者从设计模型到规范代码的实现，DDD可视化平台提供了一种平台模型到代码的单向生成功能。本文介绍DDD可视化平台单向生成功能，以及设计思路，将平台模型到代码的单向生成顺畅融入到已有的研发流程中，有效降低项目设计到编码初期的开发成本。</p><h2 id="二、项目结构" tabindex="-1">二、项目结构 <a class="header-anchor" href="#二、项目结构" aria-label="Permalink to &quot;二、项目结构&quot;">​</a></h2><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">wake-code-generator			</span></span>
<span class="line"><span style="color:#babed8;">    ├── wd-generator-core		-- 核心模块</span></span>
<span class="line"><span style="color:#babed8;">    └── wd-generator-dsl		-- DSL协议结构</span></span></code></pre></div><h2 id="三、流程设计" tabindex="-1">三、流程设计 <a class="header-anchor" href="#三、流程设计" aria-label="Permalink to &quot;三、流程设计&quot;">​</a></h2><p>用户通过DDD可视化平台图形界面绘制模型后，前端根据 <a href="./DDD可视化平台的DSL设计.html">DSL协议</a> 以json的形式组装DSL模型并返回给后端，后端需要依据DSL模型生成相应的源码文件并返回。为了实现DSL模型到源码文件的生成，本模块设计了如下流程： <img src="`+t+'" alt=""><br></p><h2 id="_1、读取dsl结构" tabindex="-1">1、读取DSL结构 <a class="header-anchor" href="#_1、读取dsl结构" aria-label="Permalink to &quot;1、读取DSL结构&quot;">​</a></h2><p>依据 <a href="./DDD可视化平台的DSL设计.html">DSL协议</a>，在dsl包下定义了相应的数据结构，用于接收DSL数据。 <img src="'+o+'" alt="image.png"><br></p><h2 id="_2、构建多叉元素树-并通过访问者遍历元素树" tabindex="-1">2、构建多叉元素树，并通过访问者遍历元素树 <a class="header-anchor" href="#_2、构建多叉元素树-并通过访问者遍历元素树" aria-label="Permalink to &quot;2、构建多叉元素树，并通过访问者遍历元素树&quot;">​</a></h2><p>由于DSL数据结构较为复杂，采用直接遍历的方式将增加遍历的复杂度，为了降低遍历的复杂度、减少遍历代码的维护成本，我们将数据结构的复杂度转移到构建阶段，根据DSL构建一棵多叉树结构，简化遍历元素的过程。 多叉树节点分为如下类型：</p><ol><li>ElementNode 元素节点：抽象的节点类型，包含一个指向父节点的属性；</li><li>CompositeElement 容器节点：继承 ElementNode，并包含一个子节点列表childElementNodeList，子节点类型可以为容器节点和叶子节点；</li><li>LeafElement 叶子节点：继承 ElementNode，代表树最下层节点。</li></ol><p><img src="'+e+'" alt=""><br> 原DSL结构 构建后的元素树结构 遍历思路：深度遍历，访问元素树结构，根据元素种类往叶子元素进行遍历；同时遍历到每个元素的同时，调用元素具体的访问方法 <img src="'+p+'" alt=""><br></p><h2 id="_3、第一次遍历-访问每个元素节点-对元素的预处理-访问者执行预解析逻辑" tabindex="-1">3、第一次遍历，访问每个元素节点(对元素的预处理)，访问者执行预解析逻辑 <a class="header-anchor" href="#_3、第一次遍历-访问每个元素节点-对元素的预处理-访问者执行预解析逻辑" aria-label="Permalink to &quot;3、第一次遍历，访问每个元素节点(对元素的预处理)，访问者执行预解析逻辑&quot;">​</a></h2><blockquote><p>Tips: 该阶段可以做一些数据预处理操作（关系缓存、字段修改）</p></blockquote><p>根据深度遍历访问每一个元素并调用访问者提供的预处理方法； 访问者内部根据元素的类名获取元素相对应的策略类，并执行相对应的预处理策略 <img src="'+c+'" alt=""><br></p><h2 id="_4、第二次遍历-访问每个元素节点-预处理后的元素-访问者执行生成逻辑" tabindex="-1">4、第二次遍历，访问每个元素节点(预处理后的元素)，访问者执行生成逻辑 <a class="header-anchor" href="#_4、第二次遍历-访问每个元素节点-预处理后的元素-访问者执行生成逻辑" aria-label="Permalink to &quot;4、第二次遍历，访问每个元素节点(预处理后的元素)，访问者执行生成逻辑&quot;">​</a></h2><blockquote><p>Tips: 该阶段为核心生成逻辑（代码生成、文件输出、流操作）</p></blockquote><p>同上，根据深度遍历访问每一个元素并调用访问者提供的生成方法； 访问者内部根据元素的类名获取元素相对应的策略类，并执行相对应的生成策略 <img src="'+i+`" alt=""><br></p><h2 id="_5、执行统一后置处理" tabindex="-1">5、执行统一后置处理 <a class="header-anchor" href="#_5、执行统一后置处理" aria-label="Permalink to &quot;5、执行统一后置处理&quot;">​</a></h2><p>对ThreadLocal线程上下文进行清理等统一后置处理操作。</p><h2 id="四、访问者模式" tabindex="-1">四、访问者模式 <a class="header-anchor" href="#四、访问者模式" aria-label="Permalink to &quot;四、访问者模式&quot;">​</a></h2><blockquote><p>由上述流程设计可知，访问者需要提供预处理、生成逻辑、后置处理等功能，因此定义一个访问者接口，具体逻辑由不同访问者实现。</p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 访问者, 提供具体元素的操作方法</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * </span><span style="color:#F78C6C;font-style:italic;">@author</span><span style="color:#676E95;font-style:italic;"> shimmer</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">interface</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Visitor</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 预解析元素方法</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">elementNode</span><span style="color:#676E95;font-style:italic;"> 元素节点</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">void</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">preHandle</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">ElementNode</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">elementNode</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 元素生成方法</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">elementNode</span><span style="color:#676E95;font-style:italic;"> 元素节点</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">void</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">generate</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">ElementNode</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">elementNode</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 统一后置处理方法</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">void</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">globalAfterHandle</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="velocity模版引擎实现生成逻辑" tabindex="-1">Velocity模版引擎实现生成逻辑 <a class="header-anchor" href="#velocity模版引擎实现生成逻辑" aria-label="Permalink to &quot;Velocity模版引擎实现生成逻辑&quot;">​</a></h2><blockquote><p>原理：Velocity模版引擎是一种静态生成模版文件的模版引擎，基于vm模版语法和模版上下文替换对应的模版变量，可以得到替换后的模版文件流。</p></blockquote><p>实现逻辑：填充变量到Velocity上下文、获取需要生成的模版路径，然后将原始路径解析为输出路径，最后调用Velocity模版引擎生成新文件。 <img src="`+r+`" alt=""><br> 封装变化点：根据上述过程，将变量填充、模版路径列表获取、解析路径等变化点封装到接口中，由不同元素提供具体实现逻辑。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * Velocity模版引擎生成接口</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * </span><span style="color:#F78C6C;font-style:italic;">@author</span><span style="color:#676E95;font-style:italic;"> ZhuXueLiang</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * </span><span style="color:#F78C6C;font-style:italic;">@version</span><span style="color:#676E95;font-style:italic;"> 1.0</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">interface</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">VelocityTemplateGenerate</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">extends</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">ElementStrategy</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 获取生成需要的模版路径列表</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@return</span><span style="color:#676E95;font-style:italic;"> 模版路径列表</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">List</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">getTemplatePathList</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 填充当前元素标签到上下文中,用于进行变量映射</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">context</span><span style="color:#676E95;font-style:italic;"> velocity上下文</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">void</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">putVelocityContext</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">VelocityContext</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">context</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 解析输出路径</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">templateUrl</span><span style="color:#676E95;font-style:italic;">   需要解析的模版路径</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">preFixOutPath</span><span style="color:#676E95;font-style:italic;"> 目标路径</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@return</span><span style="color:#676E95;font-style:italic;"> 输出路径</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">String</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">parseOutputPath</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">templateUrl</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">String</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">preFixOutPath</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 处理逻辑(处理各个元素的单独逻辑)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#BABED8;font-style:italic;">templateContext</span><span style="color:#676E95;font-style:italic;"> 上下文信息</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@return</span><span style="color:#676E95;font-style:italic;"> true/false</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#C792EA;">Boolean</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">process</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">TemplateContext</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">templateContext</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div>`,28),f=[E];function D(d,B,h,A,m,F){return a(),n("div",null,f)}const C=s(y,[["render",D]]);export{u as __pageData,C as default};
